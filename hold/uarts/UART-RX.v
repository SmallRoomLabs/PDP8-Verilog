// 	 ICESTORM_LC:    54/ 1280     4%
// 	ICESTORM_RAM:     0/   16     0%
// 	       SB_IO:    68/  112    60%
// 	       SB_GB:     1/    8    12%
// 	ICESTORM_PLL:     0/    1     0%
// 	 SB_WARMBOOT:     0/    1     0%
// --TIMING
//         Timing estimate: 7.30 ns (137.06 MHz)
        
        /*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module top(input SYSCLK, inout P0,P1,P2,P3,P4,P5,P6,P7,P8,P9,P10,P11,P12,P13,P14,P15,P16,P17,P18,P19,P20,P21,P22,P23,P24,P25,P26,P27,P28,P29,P30,P31,P32,P33,P34,P35,P36,P37,P38,P39,P40,P41,P42,P43,P44,P45,P46,P47,P48,P49,P50,P51,P52,P53,P54,P55,P56,P57,P58,P59,P60,P61,P62,P63,P64,P65,P66);
  \UART-RX dut(
    P0,SYSCLK,P1,P2,{P10,P11,P12,P13,P14,P15,P16,P17},P3,P4
  );
endmodule



module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule

module DIG_D_FF_1bit
#(
    parameter Default = 0
)
(
   input D,
   input C,
   output Q,
   output \~Q
);
    reg state;

    assign Q = state;
    assign \~Q = ~state;

    always @ (posedge C) begin
        state <= D;
    end

    initial begin
        state = Default;
    end
endmodule


module RS (
  input S,
  input C,
  input R,
  input en,
  output Q
);
  wire s0;
  wire Q_temp;
  wire s1;
  assign s1 = ((Q_temp & ~ R) | (~ R & S));
  Mux_2x1 Mux_2x1_i0 (
    .sel( en ),
    .in_0( Q_temp ),
    .in_1( s1 ),
    .out( s0 )
  );
  // Q_0^n
  DIG_D_FF_1bit #(
    .Default(0)
  )
  DIG_D_FF_1bit_i1 (
    .D( s0 ),
    .C( C ),
    .Q( Q_temp )
  );
  assign Q = Q_temp;
endmodule

module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module DIG_ROM_16X8_SAMPLETIMES (
    input [3:0] A,
    input sel,
    output reg [7:0] D
);
    reg [7:0] my_rom [0:8];

    always @ (*) begin
        if (~sel)
            D = 8'hz;
        else if (A > 4'h8)
            D = 8'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 8'h18;
        my_rom[1] = 8'h28;
        my_rom[2] = 8'h38;
        my_rom[3] = 8'h48;
        my_rom[4] = 8'h58;
        my_rom[5] = 8'h68;
        my_rom[6] = 8'h78;
        my_rom[7] = 8'h88;
        my_rom[8] = 8'h9e;
    end
endmodule

module \UART-RX  (
  input RX, // data in
  input clk16,
  input CDP, // clear data present flag
  input en, // enables the clock input
  output [7:0] DATA, // received data
  output DP, // data present
  output busy // Receiver is busy.
              // There is a byte incomming.

);
  wire s0;
  wire s1;
  wire [7:0] s2;
  wire [7:0] s3;
  wire s4;
  wire [3:0] s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire [7:0] s15;
  wire s16;
  wire busy_temp;
  DIG_Register DIG_Register_i0 (
    .D( RX ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s14 )
  );
  RS RS_i1 (
    .S( s6 ),
    .C( clk16 ),
    .R( CDP ),
    .en( en ),
    .Q( DP )
  );
  assign s0 = (busy_temp & en);
  assign s16 = (s6 & en);
  RS RS_i2 (
    .S( RX ),
    .C( clk16 ),
    .R( s1 ),
    .en( en ),
    .Q( busy_temp )
  );
  DIG_Counter_Nbit #(
    .Bits(8)
  )
  DIG_Counter_Nbit_i3 (
    .en( s0 ),
    .C( clk16 ),
    .clr( s1 ),
    .out( s2 )
  );
  DIG_Register DIG_Register_i4 (
    .D( s14 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s13 )
  );
  assign s15[0] = s8;
  assign s15[1] = s7;
  assign s15[2] = s9;
  assign s15[3] = s10;
  assign s15[4] = s11;
  assign s15[5] = s12;
  assign s15[6] = s13;
  assign s15[7] = s14;
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i5 (
    .D( s15 ),
    .C( clk16 ),
    .en( s16 ),
    .Q( DATA )
  );
  CompUnsigned #(
    .Bits(8)
  )
  CompUnsigned_i6 (
    .a( s3 ),
    .b( s2 ),
    .\= ( s4 )
  );
  DIG_Register DIG_Register_i7 (
    .D( s13 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s12 )
  );
  DIG_Register DIG_Register_i8 (
    .D( s12 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s11 )
  );
  DIG_Register DIG_Register_i9 (
    .D( s11 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s10 )
  );
  DIG_Register DIG_Register_i10 (
    .D( s10 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s9 )
  );
  DIG_Register DIG_Register_i11 (
    .D( s9 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s7 )
  );
  DIG_Register DIG_Register_i12 (
    .D( s7 ),
    .C( clk16 ),
    .en( s4 ),
    .Q( s8 )
  );
  DIG_Counter_Nbit #(
    .Bits(4)
  )
  DIG_Counter_Nbit_i13 (
    .en( s4 ),
    .C( clk16 ),
    .clr( s1 ),
    .out( s5 )
  );
  // SAMPLETIMES
  DIG_ROM_16X8_SAMPLETIMES DIG_ROM_16X8_SAMPLETIMES_i14 (
    .A( s5 ),
    .sel( 1'b1 ),
    .D( s3 )
  );
  CompUnsigned #(
    .Bits(4)
  )
  CompUnsigned_i15 (
    .a( s5 ),
    .b( 4'b1000 ),
    .\> ( s1 ),
    .\= ( s6 )
  );
  assign busy = busy_temp;
endmodule
